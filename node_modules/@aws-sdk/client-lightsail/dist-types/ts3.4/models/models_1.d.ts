import {
  AccessDirection,
  AccessRules,
  AddOn,
  AlarmState,
  AvailabilityZone,
  Bucket,
  BucketAccessLogConfig,
  CacheBehavior,
  CacheBehaviorPerPath,
  CacheSettings,
  ComparisonOperator,
  ContactMethodVerificationProtocol,
  ContactProtocol,
  ContainerImage,
  ContainerService,
  ContainerServicePowerName,
  CostEstimate,
  Disk,
  DiskSnapshot,
  DistributionBundle,
  DistributionMetricName,
  Domain,
  DomainEntry,
  ExportSnapshotRecord,
  InputOrigin,
  IpAddressType,
  KeyPair,
  LightsailDistribution,
  MetricDatapoint,
  MetricName,
  MetricStatistic,
  MetricUnit,
  NetworkProtocol,
  Operation,
  PortInfo,
  PrivateRegistryAccessRequest,
  RegionName,
  ResourceLocation,
  ResourceType,
  Tag,
  TreatMissingData,
} from "./models_0";
export interface GetCostEstimateRequest {
  resourceName: string | undefined;
  startTime: Date | undefined;
  endTime: Date | undefined;
}
export interface ResourceBudgetEstimate {
  resourceName?: string;
  resourceType?: ResourceType | string;
  costEstimates?: CostEstimate[];
  startTime?: Date;
  endTime?: Date;
}
export interface GetCostEstimateResult {
  resourcesBudgetEstimate?: ResourceBudgetEstimate[];
}
export interface GetDiskRequest {
  diskName: string | undefined;
}
export interface GetDiskResult {
  disk?: Disk;
}
export interface GetDisksRequest {
  pageToken?: string;
}
export interface GetDisksResult {
  disks?: Disk[];
  nextPageToken?: string;
}
export interface GetDiskSnapshotRequest {
  diskSnapshotName: string | undefined;
}
export interface GetDiskSnapshotResult {
  diskSnapshot?: DiskSnapshot;
}
export interface GetDiskSnapshotsRequest {
  pageToken?: string;
}
export interface GetDiskSnapshotsResult {
  diskSnapshots?: DiskSnapshot[];
  nextPageToken?: string;
}
export interface GetDistributionBundlesRequest {}
export interface GetDistributionBundlesResult {
  bundles?: DistributionBundle[];
}
export interface GetDistributionLatestCacheResetRequest {
  distributionName?: string;
}
export interface GetDistributionLatestCacheResetResult {
  status?: string;
  createTime?: Date;
}
export interface GetDistributionMetricDataRequest {
  distributionName: string | undefined;
  metricName: DistributionMetricName | string | undefined;
  startTime: Date | undefined;
  endTime: Date | undefined;
  period: number | undefined;
  unit: MetricUnit | string | undefined;
  statistics: (MetricStatistic | string)[] | undefined;
}
export interface GetDistributionMetricDataResult {
  metricName?: DistributionMetricName | string;
  metricData?: MetricDatapoint[];
}
export interface GetDistributionsRequest {
  distributionName?: string;
  pageToken?: string;
}
export interface GetDistributionsResult {
  distributions?: LightsailDistribution[];
  nextPageToken?: string;
}
export interface GetDomainRequest {
  domainName: string | undefined;
}
export interface GetDomainResult {
  domain?: Domain;
}
export interface GetDomainsRequest {
  pageToken?: string;
}
export interface GetDomainsResult {
  domains?: Domain[];
  nextPageToken?: string;
}
export interface GetExportSnapshotRecordsRequest {
  pageToken?: string;
}
export interface GetExportSnapshotRecordsResult {
  exportSnapshotRecords?: ExportSnapshotRecord[];
  nextPageToken?: string;
}
export interface GetInstanceRequest {
  instanceName: string | undefined;
}
export interface InstanceHardware {
  cpuCount?: number;
  disks?: Disk[];
  ramSizeInGb?: number;
}
export declare const HttpEndpoint: {
  readonly disabled: "disabled";
  readonly enabled: "enabled";
};
export type HttpEndpoint = (typeof HttpEndpoint)[keyof typeof HttpEndpoint];
export declare const HttpProtocolIpv6: {
  readonly disabled: "disabled";
  readonly enabled: "enabled";
};
export type HttpProtocolIpv6 =
  (typeof HttpProtocolIpv6)[keyof typeof HttpProtocolIpv6];
export declare const HttpTokens: {
  readonly optional: "optional";
  readonly required: "required";
};
export type HttpTokens = (typeof HttpTokens)[keyof typeof HttpTokens];
export declare const InstanceMetadataState: {
  readonly applied: "applied";
  readonly pending: "pending";
};
export type InstanceMetadataState =
  (typeof InstanceMetadataState)[keyof typeof InstanceMetadataState];
export interface InstanceMetadataOptions {
  state?: InstanceMetadataState | string;
  httpTokens?: HttpTokens | string;
  httpEndpoint?: HttpEndpoint | string;
  httpPutResponseHopLimit?: number;
  httpProtocolIpv6?: HttpProtocolIpv6 | string;
}
export interface MonthlyTransfer {
  gbPerMonthAllocated?: number;
}
export declare const PortAccessType: {
  readonly Private: "Private";
  readonly Public: "Public";
};
export type PortAccessType =
  (typeof PortAccessType)[keyof typeof PortAccessType];
export interface InstancePortInfo {
  fromPort?: number;
  toPort?: number;
  protocol?: NetworkProtocol | string;
  accessFrom?: string;
  accessType?: PortAccessType | string;
  commonName?: string;
  accessDirection?: AccessDirection | string;
  cidrs?: string[];
  ipv6Cidrs?: string[];
  cidrListAliases?: string[];
}
export interface InstanceNetworking {
  monthlyTransfer?: MonthlyTransfer;
  ports?: InstancePortInfo[];
}
export interface InstanceState {
  code?: number;
  name?: string;
}
export interface Instance {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType | string;
  tags?: Tag[];
  blueprintId?: string;
  blueprintName?: string;
  bundleId?: string;
  addOns?: AddOn[];
  isStaticIp?: boolean;
  privateIpAddress?: string;
  publicIpAddress?: string;
  ipv6Addresses?: string[];
  ipAddressType?: IpAddressType | string;
  hardware?: InstanceHardware;
  networking?: InstanceNetworking;
  state?: InstanceState;
  username?: string;
  sshKeyName?: string;
  metadataOptions?: InstanceMetadataOptions;
}
export interface GetInstanceResult {
  instance?: Instance;
}
export declare const InstanceAccessProtocol: {
  readonly rdp: "rdp";
  readonly ssh: "ssh";
};
export type InstanceAccessProtocol =
  (typeof InstanceAccessProtocol)[keyof typeof InstanceAccessProtocol];
export interface GetInstanceAccessDetailsRequest {
  instanceName: string | undefined;
  protocol?: InstanceAccessProtocol | string;
}
export interface HostKeyAttributes {
  algorithm?: string;
  publicKey?: string;
  witnessedAt?: Date;
  fingerprintSHA1?: string;
  fingerprintSHA256?: string;
  notValidBefore?: Date;
  notValidAfter?: Date;
}
export interface PasswordData {
  ciphertext?: string;
  keyPairName?: string;
}
export interface InstanceAccessDetails {
  certKey?: string;
  expiresAt?: Date;
  ipAddress?: string;
  password?: string;
  passwordData?: PasswordData;
  privateKey?: string;
  protocol?: InstanceAccessProtocol | string;
  instanceName?: string;
  username?: string;
  hostKeys?: HostKeyAttributes[];
}
export interface GetInstanceAccessDetailsResult {
  accessDetails?: InstanceAccessDetails;
}
export declare const InstanceMetricName: {
  readonly BurstCapacityPercentage: "BurstCapacityPercentage";
  readonly BurstCapacityTime: "BurstCapacityTime";
  readonly CPUUtilization: "CPUUtilization";
  readonly MetadataNoToken: "MetadataNoToken";
  readonly NetworkIn: "NetworkIn";
  readonly NetworkOut: "NetworkOut";
  readonly StatusCheckFailed: "StatusCheckFailed";
  readonly StatusCheckFailed_Instance: "StatusCheckFailed_Instance";
  readonly StatusCheckFailed_System: "StatusCheckFailed_System";
};
export type InstanceMetricName =
  (typeof InstanceMetricName)[keyof typeof InstanceMetricName];
export interface GetInstanceMetricDataRequest {
  instanceName: string | undefined;
  metricName: InstanceMetricName | string | undefined;
  period: number | undefined;
  startTime: Date | undefined;
  endTime: Date | undefined;
  unit: MetricUnit | string | undefined;
  statistics: (MetricStatistic | string)[] | undefined;
}
export interface GetInstanceMetricDataResult {
  metricName?: InstanceMetricName | string;
  metricData?: MetricDatapoint[];
}
export interface GetInstancePortStatesRequest {
  instanceName: string | undefined;
}
export declare const PortState: {
  readonly Closed: "closed";
  readonly Open: "open";
};
export type PortState = (typeof PortState)[keyof typeof PortState];
export interface InstancePortState {
  fromPort?: number;
  toPort?: number;
  protocol?: NetworkProtocol | string;
  state?: PortState | string;
  cidrs?: string[];
  ipv6Cidrs?: string[];
  cidrListAliases?: string[];
}
export interface GetInstancePortStatesResult {
  portStates?: InstancePortState[];
}
export interface GetInstancesRequest {
  pageToken?: string;
}
export interface GetInstancesResult {
  instances?: Instance[];
  nextPageToken?: string;
}
export interface GetInstanceSnapshotRequest {
  instanceSnapshotName: string | undefined;
}
export declare const InstanceSnapshotState: {
  readonly Available: "available";
  readonly Error: "error";
  readonly Pending: "pending";
};
export type InstanceSnapshotState =
  (typeof InstanceSnapshotState)[keyof typeof InstanceSnapshotState];
export interface InstanceSnapshot {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType | string;
  tags?: Tag[];
  state?: InstanceSnapshotState | string;
  progress?: string;
  fromAttachedDisks?: Disk[];
  fromInstanceName?: string;
  fromInstanceArn?: string;
  fromBlueprintId?: string;
  fromBundleId?: string;
  isFromAutoSnapshot?: boolean;
  sizeInGb?: number;
}
export interface GetInstanceSnapshotResult {
  instanceSnapshot?: InstanceSnapshot;
}
export interface GetInstanceSnapshotsRequest {
  pageToken?: string;
}
export interface GetInstanceSnapshotsResult {
  instanceSnapshots?: InstanceSnapshot[];
  nextPageToken?: string;
}
export interface GetInstanceStateRequest {
  instanceName: string | undefined;
}
export interface GetInstanceStateResult {
  state?: InstanceState;
}
export interface GetKeyPairRequest {
  keyPairName: string | undefined;
}
export interface GetKeyPairResult {
  keyPair?: KeyPair;
}
export interface GetKeyPairsRequest {
  pageToken?: string;
  includeDefaultKeyPair?: boolean;
}
export interface GetKeyPairsResult {
  keyPairs?: KeyPair[];
  nextPageToken?: string;
}
export interface GetLoadBalancerRequest {
  loadBalancerName: string | undefined;
}
export declare const LoadBalancerAttributeName: {
  readonly HealthCheckPath: "HealthCheckPath";
  readonly HttpsRedirectionEnabled: "HttpsRedirectionEnabled";
  readonly SessionStickinessEnabled: "SessionStickinessEnabled";
  readonly SessionStickiness_LB_CookieDurationSeconds: "SessionStickiness_LB_CookieDurationSeconds";
  readonly TlsPolicyName: "TlsPolicyName";
};
export type LoadBalancerAttributeName =
  (typeof LoadBalancerAttributeName)[keyof typeof LoadBalancerAttributeName];
export declare const InstanceHealthState: {
  readonly Draining: "draining";
  readonly Healthy: "healthy";
  readonly Initial: "initial";
  readonly Unavailable: "unavailable";
  readonly Unhealthy: "unhealthy";
  readonly Unused: "unused";
};
export type InstanceHealthState =
  (typeof InstanceHealthState)[keyof typeof InstanceHealthState];
export declare const InstanceHealthReason: {
  readonly InstanceDeregistrationInProgress: "Instance.DeregistrationInProgress";
  readonly InstanceFailedHealthChecks: "Instance.FailedHealthChecks";
  readonly InstanceInvalidState: "Instance.InvalidState";
  readonly InstanceIpUnusable: "Instance.IpUnusable";
  readonly InstanceNotInUse: "Instance.NotInUse";
  readonly InstanceNotRegistered: "Instance.NotRegistered";
  readonly InstanceResponseCodeMismatch: "Instance.ResponseCodeMismatch";
  readonly InstanceTimeout: "Instance.Timeout";
  readonly LbInitialHealthChecking: "Lb.InitialHealthChecking";
  readonly LbInternalError: "Lb.InternalError";
  readonly LbRegistrationInProgress: "Lb.RegistrationInProgress";
};
export type InstanceHealthReason =
  (typeof InstanceHealthReason)[keyof typeof InstanceHealthReason];
export interface InstanceHealthSummary {
  instanceName?: string;
  instanceHealth?: InstanceHealthState | string;
  instanceHealthReason?: InstanceHealthReason | string;
}
export declare const LoadBalancerProtocol: {
  readonly HTTP: "HTTP";
  readonly HTTP_HTTPS: "HTTP_HTTPS";
};
export type LoadBalancerProtocol =
  (typeof LoadBalancerProtocol)[keyof typeof LoadBalancerProtocol];
export declare const LoadBalancerState: {
  readonly Active: "active";
  readonly ActiveImpaired: "active_impaired";
  readonly Failed: "failed";
  readonly Provisioning: "provisioning";
  readonly Unknown: "unknown";
};
export type LoadBalancerState =
  (typeof LoadBalancerState)[keyof typeof LoadBalancerState];
export interface LoadBalancerTlsCertificateSummary {
  name?: string;
  isAttached?: boolean;
}
export interface LoadBalancer {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType | string;
  tags?: Tag[];
  dnsName?: string;
  state?: LoadBalancerState | string;
  protocol?: LoadBalancerProtocol | string;
  publicPorts?: number[];
  healthCheckPath?: string;
  instancePort?: number;
  instanceHealthSummary?: InstanceHealthSummary[];
  tlsCertificateSummaries?: LoadBalancerTlsCertificateSummary[];
  configurationOptions?: Record<string, string>;
  ipAddressType?: IpAddressType | string;
  httpsRedirectionEnabled?: boolean;
  tlsPolicyName?: string;
}
export interface GetLoadBalancerResult {
  loadBalancer?: LoadBalancer;
}
export declare const LoadBalancerMetricName: {
  readonly ClientTLSNegotiationErrorCount: "ClientTLSNegotiationErrorCount";
  readonly HTTPCode_Instance_2XX_Count: "HTTPCode_Instance_2XX_Count";
  readonly HTTPCode_Instance_3XX_Count: "HTTPCode_Instance_3XX_Count";
  readonly HTTPCode_Instance_4XX_Count: "HTTPCode_Instance_4XX_Count";
  readonly HTTPCode_Instance_5XX_Count: "HTTPCode_Instance_5XX_Count";
  readonly HTTPCode_LB_4XX_Count: "HTTPCode_LB_4XX_Count";
  readonly HTTPCode_LB_5XX_Count: "HTTPCode_LB_5XX_Count";
  readonly HealthyHostCount: "HealthyHostCount";
  readonly InstanceResponseTime: "InstanceResponseTime";
  readonly RejectedConnectionCount: "RejectedConnectionCount";
  readonly RequestCount: "RequestCount";
  readonly UnhealthyHostCount: "UnhealthyHostCount";
};
export type LoadBalancerMetricName =
  (typeof LoadBalancerMetricName)[keyof typeof LoadBalancerMetricName];
export interface GetLoadBalancerMetricDataRequest {
  loadBalancerName: string | undefined;
  metricName: LoadBalancerMetricName | string | undefined;
  period: number | undefined;
  startTime: Date | undefined;
  endTime: Date | undefined;
  unit: MetricUnit | string | undefined;
  statistics: (MetricStatistic | string)[] | undefined;
}
export interface GetLoadBalancerMetricDataResult {
  metricName?: LoadBalancerMetricName | string;
  metricData?: MetricDatapoint[];
}
export interface GetLoadBalancersRequest {
  pageToken?: string;
}
export interface GetLoadBalancersResult {
  loadBalancers?: LoadBalancer[];
  nextPageToken?: string;
}
export interface GetLoadBalancerTlsCertificatesRequest {
  loadBalancerName: string | undefined;
}
export declare const LoadBalancerTlsCertificateDnsRecordCreationStateCode: {
  readonly Failed: "FAILED";
  readonly Started: "STARTED";
  readonly Succeeded: "SUCCEEDED";
};
export type LoadBalancerTlsCertificateDnsRecordCreationStateCode =
  (typeof LoadBalancerTlsCertificateDnsRecordCreationStateCode)[keyof typeof LoadBalancerTlsCertificateDnsRecordCreationStateCode];
export interface LoadBalancerTlsCertificateDnsRecordCreationState {
  code?: LoadBalancerTlsCertificateDnsRecordCreationStateCode | string;
  message?: string;
}
export declare const LoadBalancerTlsCertificateDomainStatus: {
  readonly Failed: "FAILED";
  readonly PendingValidation: "PENDING_VALIDATION";
  readonly Success: "SUCCESS";
};
export type LoadBalancerTlsCertificateDomainStatus =
  (typeof LoadBalancerTlsCertificateDomainStatus)[keyof typeof LoadBalancerTlsCertificateDomainStatus];
export interface LoadBalancerTlsCertificateDomainValidationRecord {
  name?: string;
  type?: string;
  value?: string;
  validationStatus?: LoadBalancerTlsCertificateDomainStatus | string;
  domainName?: string;
  dnsRecordCreationState?: LoadBalancerTlsCertificateDnsRecordCreationState;
}
export declare const LoadBalancerTlsCertificateFailureReason: {
  readonly AdditionalVerificationRequired: "ADDITIONAL_VERIFICATION_REQUIRED";
  readonly DomainNotAllowed: "DOMAIN_NOT_ALLOWED";
  readonly InvalidPublicDomain: "INVALID_PUBLIC_DOMAIN";
  readonly NoAvailableContacts: "NO_AVAILABLE_CONTACTS";
  readonly Other: "OTHER";
};
export type LoadBalancerTlsCertificateFailureReason =
  (typeof LoadBalancerTlsCertificateFailureReason)[keyof typeof LoadBalancerTlsCertificateFailureReason];
export interface LoadBalancerTlsCertificateDomainValidationOption {
  domainName?: string;
  validationStatus?: LoadBalancerTlsCertificateDomainStatus | string;
}
export declare const LoadBalancerTlsCertificateRenewalStatus: {
  readonly Failed: "FAILED";
  readonly PendingAutoRenewal: "PENDING_AUTO_RENEWAL";
  readonly PendingValidation: "PENDING_VALIDATION";
  readonly Success: "SUCCESS";
};
export type LoadBalancerTlsCertificateRenewalStatus =
  (typeof LoadBalancerTlsCertificateRenewalStatus)[keyof typeof LoadBalancerTlsCertificateRenewalStatus];
export interface LoadBalancerTlsCertificateRenewalSummary {
  renewalStatus?: LoadBalancerTlsCertificateRenewalStatus | string;
  domainValidationOptions?: LoadBalancerTlsCertificateDomainValidationOption[];
}
export declare const LoadBalancerTlsCertificateRevocationReason: {
  readonly AACompromise: "A_A_COMPROMISE";
  readonly AffiliationChanged: "AFFILIATION_CHANGED";
  readonly CaCompromise: "CA_COMPROMISE";
  readonly CertificateHold: "CERTIFICATE_HOLD";
  readonly CessationOfOperation: "CESSATION_OF_OPERATION";
  readonly KeyCompromise: "KEY_COMPROMISE";
  readonly PrivilegeWithdrawn: "PRIVILEGE_WITHDRAWN";
  readonly RemoveFromCrl: "REMOVE_FROM_CRL";
  readonly Superceded: "SUPERCEDED";
  readonly Unspecified: "UNSPECIFIED";
};
export type LoadBalancerTlsCertificateRevocationReason =
  (typeof LoadBalancerTlsCertificateRevocationReason)[keyof typeof LoadBalancerTlsCertificateRevocationReason];
export declare const LoadBalancerTlsCertificateStatus: {
  readonly Expired: "EXPIRED";
  readonly Failed: "FAILED";
  readonly Inactive: "INACTIVE";
  readonly Issued: "ISSUED";
  readonly PendingValidation: "PENDING_VALIDATION";
  readonly Revoked: "REVOKED";
  readonly Unknown: "UNKNOWN";
  readonly ValidationTimedOut: "VALIDATION_TIMED_OUT";
};
export type LoadBalancerTlsCertificateStatus =
  (typeof LoadBalancerTlsCertificateStatus)[keyof typeof LoadBalancerTlsCertificateStatus];
export interface LoadBalancerTlsCertificate {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType | string;
  tags?: Tag[];
  loadBalancerName?: string;
  isAttached?: boolean;
  status?: LoadBalancerTlsCertificateStatus | string;
  domainName?: string;
  domainValidationRecords?: LoadBalancerTlsCertificateDomainValidationRecord[];
  failureReason?: LoadBalancerTlsCertificateFailureReason | string;
  issuedAt?: Date;
  issuer?: string;
  keyAlgorithm?: string;
  notAfter?: Date;
  notBefore?: Date;
  renewalSummary?: LoadBalancerTlsCertificateRenewalSummary;
  revocationReason?: LoadBalancerTlsCertificateRevocationReason | string;
  revokedAt?: Date;
  serial?: string;
  signatureAlgorithm?: string;
  subject?: string;
  subjectAlternativeNames?: string[];
}
export interface GetLoadBalancerTlsCertificatesResult {
  tlsCertificates?: LoadBalancerTlsCertificate[];
}
export interface GetLoadBalancerTlsPoliciesRequest {
  pageToken?: string;
}
export interface LoadBalancerTlsPolicy {
  name?: string;
  isDefault?: boolean;
  description?: string;
  protocols?: string[];
  ciphers?: string[];
}
export interface GetLoadBalancerTlsPoliciesResult {
  tlsPolicies?: LoadBalancerTlsPolicy[];
  nextPageToken?: string;
}
export interface GetOperationRequest {
  operationId: string | undefined;
}
export interface GetOperationResult {
  operation?: Operation;
}
export interface GetOperationsRequest {
  pageToken?: string;
}
export interface GetOperationsResult {
  operations?: Operation[];
  nextPageToken?: string;
}
export interface GetOperationsForResourceRequest {
  resourceName: string | undefined;
  pageToken?: string;
}
export interface GetOperationsForResourceResult {
  operations?: Operation[];
  nextPageCount?: string;
  nextPageToken?: string;
}
export interface GetRegionsRequest {
  includeAvailabilityZones?: boolean;
  includeRelationalDatabaseAvailabilityZones?: boolean;
}
export interface Region {
  continentCode?: string;
  description?: string;
  displayName?: string;
  name?: RegionName | string;
  availabilityZones?: AvailabilityZone[];
  relationalDatabaseAvailabilityZones?: AvailabilityZone[];
}
export interface GetRegionsResult {
  regions?: Region[];
}
export interface GetRelationalDatabaseRequest {
  relationalDatabaseName: string | undefined;
}
export interface RelationalDatabaseHardware {
  cpuCount?: number;
  diskSizeInGb?: number;
  ramSizeInGb?: number;
}
export interface RelationalDatabaseEndpoint {
  port?: number;
  address?: string;
}
export interface PendingMaintenanceAction {
  action?: string;
  description?: string;
  currentApplyDate?: Date;
}
export interface PendingModifiedRelationalDatabaseValues {
  masterUserPassword?: string;
  engineVersion?: string;
  backupRetentionEnabled?: boolean;
}
export interface RelationalDatabase {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType | string;
  tags?: Tag[];
  relationalDatabaseBlueprintId?: string;
  relationalDatabaseBundleId?: string;
  masterDatabaseName?: string;
  hardware?: RelationalDatabaseHardware;
  state?: string;
  secondaryAvailabilityZone?: string;
  backupRetentionEnabled?: boolean;
  pendingModifiedValues?: PendingModifiedRelationalDatabaseValues;
  engine?: string;
  engineVersion?: string;
  latestRestorableTime?: Date;
  masterUsername?: string;
  parameterApplyStatus?: string;
  preferredBackupWindow?: string;
  preferredMaintenanceWindow?: string;
  publiclyAccessible?: boolean;
  masterEndpoint?: RelationalDatabaseEndpoint;
  pendingMaintenanceActions?: PendingMaintenanceAction[];
  caCertificateIdentifier?: string;
}
export interface GetRelationalDatabaseResult {
  relationalDatabase?: RelationalDatabase;
}
export interface GetRelationalDatabaseBlueprintsRequest {
  pageToken?: string;
}
export declare const RelationalDatabaseEngine: {
  readonly MYSQL: "mysql";
};
export type RelationalDatabaseEngine =
  (typeof RelationalDatabaseEngine)[keyof typeof RelationalDatabaseEngine];
export interface RelationalDatabaseBlueprint {
  blueprintId?: string;
  engine?: RelationalDatabaseEngine | string;
  engineVersion?: string;
  engineDescription?: string;
  engineVersionDescription?: string;
  isEngineDefault?: boolean;
}
export interface GetRelationalDatabaseBlueprintsResult {
  blueprints?: RelationalDatabaseBlueprint[];
  nextPageToken?: string;
}
export interface GetRelationalDatabaseBundlesRequest {
  pageToken?: string;
  includeInactive?: boolean;
}
export interface RelationalDatabaseBundle {
  bundleId?: string;
  name?: string;
  price?: number;
  ramSizeInGb?: number;
  diskSizeInGb?: number;
  transferPerMonthInGb?: number;
  cpuCount?: number;
  isEncrypted?: boolean;
  isActive?: boolean;
}
export interface GetRelationalDatabaseBundlesResult {
  bundles?: RelationalDatabaseBundle[];
  nextPageToken?: string;
}
export interface GetRelationalDatabaseEventsRequest {
  relationalDatabaseName: string | undefined;
  durationInMinutes?: number;
  pageToken?: string;
}
export interface RelationalDatabaseEvent {
  resource?: string;
  createdAt?: Date;
  message?: string;
  eventCategories?: string[];
}
export interface GetRelationalDatabaseEventsResult {
  relationalDatabaseEvents?: RelationalDatabaseEvent[];
  nextPageToken?: string;
}
export interface GetRelationalDatabaseLogEventsRequest {
  relationalDatabaseName: string | undefined;
  logStreamName: string | undefined;
  startTime?: Date;
  endTime?: Date;
  startFromHead?: boolean;
  pageToken?: string;
}
export interface LogEvent {
  createdAt?: Date;
  message?: string;
}
export interface GetRelationalDatabaseLogEventsResult {
  resourceLogEvents?: LogEvent[];
  nextBackwardToken?: string;
  nextForwardToken?: string;
}
export interface GetRelationalDatabaseLogStreamsRequest {
  relationalDatabaseName: string | undefined;
}
export interface GetRelationalDatabaseLogStreamsResult {
  logStreams?: string[];
}
export declare const RelationalDatabasePasswordVersion: {
  readonly CURRENT: "CURRENT";
  readonly PENDING: "PENDING";
  readonly PREVIOUS: "PREVIOUS";
};
export type RelationalDatabasePasswordVersion =
  (typeof RelationalDatabasePasswordVersion)[keyof typeof RelationalDatabasePasswordVersion];
export interface GetRelationalDatabaseMasterUserPasswordRequest {
  relationalDatabaseName: string | undefined;
  passwordVersion?: RelationalDatabasePasswordVersion | string;
}
export interface GetRelationalDatabaseMasterUserPasswordResult {
  masterUserPassword?: string;
  createdAt?: Date;
}
export declare const RelationalDatabaseMetricName: {
  readonly CPUUtilization: "CPUUtilization";
  readonly DatabaseConnections: "DatabaseConnections";
  readonly DiskQueueDepth: "DiskQueueDepth";
  readonly FreeStorageSpace: "FreeStorageSpace";
  readonly NetworkReceiveThroughput: "NetworkReceiveThroughput";
  readonly NetworkTransmitThroughput: "NetworkTransmitThroughput";
};
export type RelationalDatabaseMetricName =
  (typeof RelationalDatabaseMetricName)[keyof typeof RelationalDatabaseMetricName];
export interface GetRelationalDatabaseMetricDataRequest {
  relationalDatabaseName: string | undefined;
  metricName: RelationalDatabaseMetricName | string | undefined;
  period: number | undefined;
  startTime: Date | undefined;
  endTime: Date | undefined;
  unit: MetricUnit | string | undefined;
  statistics: (MetricStatistic | string)[] | undefined;
}
export interface GetRelationalDatabaseMetricDataResult {
  metricName?: RelationalDatabaseMetricName | string;
  metricData?: MetricDatapoint[];
}
export interface GetRelationalDatabaseParametersRequest {
  relationalDatabaseName: string | undefined;
  pageToken?: string;
}
export interface RelationalDatabaseParameter {
  allowedValues?: string;
  applyMethod?: string;
  applyType?: string;
  dataType?: string;
  description?: string;
  isModifiable?: boolean;
  parameterName?: string;
  parameterValue?: string;
}
export interface GetRelationalDatabaseParametersResult {
  parameters?: RelationalDatabaseParameter[];
  nextPageToken?: string;
}
export interface GetRelationalDatabasesRequest {
  pageToken?: string;
}
export interface GetRelationalDatabasesResult {
  relationalDatabases?: RelationalDatabase[];
  nextPageToken?: string;
}
export interface GetRelationalDatabaseSnapshotRequest {
  relationalDatabaseSnapshotName: string | undefined;
}
export interface RelationalDatabaseSnapshot {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType | string;
  tags?: Tag[];
  engine?: string;
  engineVersion?: string;
  sizeInGb?: number;
  state?: string;
  fromRelationalDatabaseName?: string;
  fromRelationalDatabaseArn?: string;
  fromRelationalDatabaseBundleId?: string;
  fromRelationalDatabaseBlueprintId?: string;
}
export interface GetRelationalDatabaseSnapshotResult {
  relationalDatabaseSnapshot?: RelationalDatabaseSnapshot;
}
export interface GetRelationalDatabaseSnapshotsRequest {
  pageToken?: string;
}
export interface GetRelationalDatabaseSnapshotsResult {
  relationalDatabaseSnapshots?: RelationalDatabaseSnapshot[];
  nextPageToken?: string;
}
export interface GetStaticIpRequest {
  staticIpName: string | undefined;
}
export interface StaticIp {
  name?: string;
  arn?: string;
  supportCode?: string;
  createdAt?: Date;
  location?: ResourceLocation;
  resourceType?: ResourceType | string;
  ipAddress?: string;
  attachedTo?: string;
  isAttached?: boolean;
}
export interface GetStaticIpResult {
  staticIp?: StaticIp;
}
export interface GetStaticIpsRequest {
  pageToken?: string;
}
export interface GetStaticIpsResult {
  staticIps?: StaticIp[];
  nextPageToken?: string;
}
export interface ImportKeyPairRequest {
  keyPairName: string | undefined;
  publicKeyBase64: string | undefined;
}
export interface ImportKeyPairResult {
  operation?: Operation;
}
export interface IsVpcPeeredRequest {}
export interface IsVpcPeeredResult {
  isPeered?: boolean;
}
export interface OpenInstancePublicPortsRequest {
  portInfo: PortInfo | undefined;
  instanceName: string | undefined;
}
export interface OpenInstancePublicPortsResult {
  operation?: Operation;
}
export interface PeerVpcRequest {}
export interface PeerVpcResult {
  operation?: Operation;
}
export interface PutAlarmRequest {
  alarmName: string | undefined;
  metricName: MetricName | string | undefined;
  monitoredResourceName: string | undefined;
  comparisonOperator: ComparisonOperator | string | undefined;
  threshold: number | undefined;
  evaluationPeriods: number | undefined;
  datapointsToAlarm?: number;
  treatMissingData?: TreatMissingData | string;
  contactProtocols?: (ContactProtocol | string)[];
  notificationTriggers?: (AlarmState | string)[];
  notificationEnabled?: boolean;
}
export interface PutAlarmResult {
  operations?: Operation[];
}
export interface PutInstancePublicPortsRequest {
  portInfos: PortInfo[] | undefined;
  instanceName: string | undefined;
}
export interface PutInstancePublicPortsResult {
  operation?: Operation;
}
export interface RebootInstanceRequest {
  instanceName: string | undefined;
}
export interface RebootInstanceResult {
  operations?: Operation[];
}
export interface RebootRelationalDatabaseRequest {
  relationalDatabaseName: string | undefined;
}
export interface RebootRelationalDatabaseResult {
  operations?: Operation[];
}
export interface RegisterContainerImageRequest {
  serviceName: string | undefined;
  label: string | undefined;
  digest: string | undefined;
}
export interface RegisterContainerImageResult {
  containerImage?: ContainerImage;
}
export interface ReleaseStaticIpRequest {
  staticIpName: string | undefined;
}
export interface ReleaseStaticIpResult {
  operations?: Operation[];
}
export interface ResetDistributionCacheRequest {
  distributionName?: string;
}
export interface ResetDistributionCacheResult {
  status?: string;
  createTime?: Date;
  operation?: Operation;
}
export interface SendContactMethodVerificationRequest {
  protocol: ContactMethodVerificationProtocol | string | undefined;
}
export interface SendContactMethodVerificationResult {
  operations?: Operation[];
}
export interface SetIpAddressTypeRequest {
  resourceType: ResourceType | string | undefined;
  resourceName: string | undefined;
  ipAddressType: IpAddressType | string | undefined;
}
export interface SetIpAddressTypeResult {
  operations?: Operation[];
}
export declare const ResourceBucketAccess: {
  readonly Allow: "allow";
  readonly Deny: "deny";
};
export type ResourceBucketAccess =
  (typeof ResourceBucketAccess)[keyof typeof ResourceBucketAccess];
export interface SetResourceAccessForBucketRequest {
  resourceName: string | undefined;
  bucketName: string | undefined;
  access: ResourceBucketAccess | string | undefined;
}
export interface SetResourceAccessForBucketResult {
  operations?: Operation[];
}
export interface StartGUISessionRequest {
  resourceName: string | undefined;
}
export interface StartGUISessionResult {
  operations?: Operation[];
}
export interface StartInstanceRequest {
  instanceName: string | undefined;
}
export interface StartInstanceResult {
  operations?: Operation[];
}
export interface StartRelationalDatabaseRequest {
  relationalDatabaseName: string | undefined;
}
export interface StartRelationalDatabaseResult {
  operations?: Operation[];
}
export interface StopGUISessionRequest {
  resourceName: string | undefined;
}
export interface StopGUISessionResult {
  operations?: Operation[];
}
export interface StopInstanceRequest {
  instanceName: string | undefined;
  force?: boolean;
}
export interface StopInstanceResult {
  operations?: Operation[];
}
export interface StopRelationalDatabaseRequest {
  relationalDatabaseName: string | undefined;
  relationalDatabaseSnapshotName?: string;
}
export interface StopRelationalDatabaseResult {
  operations?: Operation[];
}
export interface TagResourceRequest {
  resourceName: string | undefined;
  resourceArn?: string;
  tags: Tag[] | undefined;
}
export interface TagResourceResult {
  operations?: Operation[];
}
export interface TestAlarmRequest {
  alarmName: string | undefined;
  state: AlarmState | string | undefined;
}
export interface TestAlarmResult {
  operations?: Operation[];
}
export interface UnpeerVpcRequest {}
export interface UnpeerVpcResult {
  operation?: Operation;
}
export interface UntagResourceRequest {
  resourceName: string | undefined;
  resourceArn?: string;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResult {
  operations?: Operation[];
}
export interface UpdateBucketRequest {
  bucketName: string | undefined;
  accessRules?: AccessRules;
  versioning?: string;
  readonlyAccessAccounts?: string[];
  accessLogConfig?: BucketAccessLogConfig;
}
export interface UpdateBucketResult {
  bucket?: Bucket;
  operations?: Operation[];
}
export interface UpdateBucketBundleRequest {
  bucketName: string | undefined;
  bundleId: string | undefined;
}
export interface UpdateBucketBundleResult {
  operations?: Operation[];
}
export interface UpdateContainerServiceRequest {
  serviceName: string | undefined;
  power?: ContainerServicePowerName | string;
  scale?: number;
  isDisabled?: boolean;
  publicDomainNames?: Record<string, string[]>;
  privateRegistryAccess?: PrivateRegistryAccessRequest;
}
export interface UpdateContainerServiceResult {
  containerService?: ContainerService;
}
export interface UpdateDistributionRequest {
  distributionName: string | undefined;
  origin?: InputOrigin;
  defaultCacheBehavior?: CacheBehavior;
  cacheBehaviorSettings?: CacheSettings;
  cacheBehaviors?: CacheBehaviorPerPath[];
  isEnabled?: boolean;
}
export interface UpdateDistributionResult {
  operation?: Operation;
}
export interface UpdateDistributionBundleRequest {
  distributionName?: string;
  bundleId?: string;
}
export interface UpdateDistributionBundleResult {
  operation?: Operation;
}
export interface UpdateDomainEntryRequest {
  domainName: string | undefined;
  domainEntry: DomainEntry | undefined;
}
export interface UpdateDomainEntryResult {
  operations?: Operation[];
}
export interface UpdateInstanceMetadataOptionsRequest {
  instanceName: string | undefined;
  httpTokens?: HttpTokens | string;
  httpEndpoint?: HttpEndpoint | string;
  httpPutResponseHopLimit?: number;
  httpProtocolIpv6?: HttpProtocolIpv6 | string;
}
export interface UpdateInstanceMetadataOptionsResult {
  operation?: Operation;
}
export interface UpdateLoadBalancerAttributeRequest {
  loadBalancerName: string | undefined;
  attributeName: LoadBalancerAttributeName | string | undefined;
  attributeValue: string | undefined;
}
export interface UpdateLoadBalancerAttributeResult {
  operations?: Operation[];
}
export interface UpdateRelationalDatabaseRequest {
  relationalDatabaseName: string | undefined;
  masterUserPassword?: string;
  rotateMasterUserPassword?: boolean;
  preferredBackupWindow?: string;
  preferredMaintenanceWindow?: string;
  enableBackupRetention?: boolean;
  disableBackupRetention?: boolean;
  publiclyAccessible?: boolean;
  applyImmediately?: boolean;
  caCertificateIdentifier?: string;
}
export interface UpdateRelationalDatabaseResult {
  operations?: Operation[];
}
export interface UpdateRelationalDatabaseParametersRequest {
  relationalDatabaseName: string | undefined;
  parameters: RelationalDatabaseParameter[] | undefined;
}
export interface UpdateRelationalDatabaseParametersResult {
  operations?: Operation[];
}
export declare const GetRelationalDatabaseMasterUserPasswordResultFilterSensitiveLog: (
  obj: GetRelationalDatabaseMasterUserPasswordResult
) => any;
export declare const UpdateRelationalDatabaseRequestFilterSensitiveLog: (
  obj: UpdateRelationalDatabaseRequest
) => any;
